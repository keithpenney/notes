Unix/Linux Shell and Environment Notes

Getting Help:
    Man Pages:
        Most commands have an entry in the "man pages" (manual) which can be accessed simply by:
            man CMD
        where 'CMD' is the command in question.
        If you don't quite recall the name of the command, you can try the "-k" (keyword) flag which will return a
        list of command names that match the keyword.
            man -k KW
        where 'KW' is the desired keyword.

        Sections:
            Man pages are broken down into numbered sections.
            To query a particular section, use:
                man N CMD
            where 'N' is the section number (see below) and 'CMD' is the command in question.
            (1)     User commands
            (2)     System calls
            (3)     Higher-level Unix programming library documentation
            (4)     Device interface and driver information
            (5)     File descriptions (system configuration files)
            (6)     Games
            (7)     File formats, conventions, and encodings (ASCII, suffixes, etc.)
            (8)     System commands and servers

    Help:
        The syntax varies from command to command, but you can usually find help by using flags '-h' or '--help'.

    Info/Texinfo:
        Some projects (primarly GNU) opt for "info" (or "texinfo") pages over man pages.  To view these, try:
            info CMD
        where 'CMD' is the command in question.

User vs. Kernel:
    Unix/Linux is broken up into various layers of abstraction.
    User Processes:
        GUIs, servers, shells, ...
    Kernel Processes:
        The Kernel (aka "OS"), system calls, process management, memory management, device drivers, ...
    Hardware:
        Processor (CPU), main memory (RAM), disks, network adapters, ...

    Code running in "Kernel Mode" has unlimited access to the processor and RAM.
    Code running in "User Mode" has limited access system resources and must go through the Kernel for access.
    Memory is broken up between "Kernel Space" (memory only the Kernel can access) and "User Space" (memory that
    user processes can access).

Display Modes:
    Unix/Linux systems have two primary display modes: text mode and graphics mode (X Window System Server)
    Historically, systems booted directly into text mode, but now most distros hide text mode during boot with
    a splash screen and switch to full graphics mode at the end of the boot process.

    Virtual Consoles:
        When a modern Linux system boots, several virtual consoles start and normally just wait for a login.
        Some of these can also be processing a 'getty' command (see below). 
        To switch from a GUI to /dev/tty1 (the first virtual console), press CTRL+ALT+F1 then to switch from
        a virtual console in text mode to any other, press ALT+F* where 'F*' is F1, F2, F3, F4, etc...
        
        You can also switch between virtual consoles with 'chvt *' where '*' is 1, 2, 3, 4, etc...
        Note:
            On kpenney-z97, the GUI is running in /dev/tty7, tty1-6 are all idling at a login prompt.

Shell Shortcuts/Hotkeys/Key Bindings:
    ctrl + _        Undo the last edit (not the last command)
    ctrl + t        Swap two characters
    alt  + t        Swap two words
    alt  + .        Print last argument from previous command
    ctrl + x + *    Expand glob/star
    ctrl + arrow    Move by words (rather than by characters)
    alt  + f        Move forward one word
    alt  + b        Move backward one word
    ctrl + x + ctrl + e     Open the command string in an editor to edit before executing
    ctrl + e        Move cursor to the end
    ctrl + a        Move cursor to the beginning
    ctrl + xx       Move to the opposite end of the line
    ctrl + u        Cut everything before the cursor
    ctrl + k        Cut everything after the cursor
    ctrl + y        Paste from the buffer
    ctrl + l        Clear screen

Common Shell Commands:
    bg [PID]                    Continue a stopped process (optional process id PID) in the background.
    blkid                       View all block devices, UUIDs, and filesystem types.
    cat [file]                  Concatenate files or StdIn and print to StdOut or redirect.
                                Prints contents of 'file' to StdOut.
    cat > filename              Redirect input from StdIn to 'filename'.  Ctrl+C to terminate.
    chmod                       Change a file's mode bits (read/write/execute)
    clear                       Clear the screen.
    command -V [cmd]            Provide a bit of information about command 'cmd'
    cp -rp FROM TO              Copy a folder (-r recursive) from path FROM to path TO (-p preserve permissions)
    date [OPTIONS]              Return the current date/time. +%s: seconds since 1/1/1970
    df [PATH]                   List filesystem, mount point, device and stats of "PATH" (defaults to all)
    diff [-r] file0 file1       Diff two files (or two directories using the -r flag)
    dmesg                       List the last kernel messages (long output! Pipe to 'less'?)
    dpkg -i filename.deb        Install a '.deb' file (always 'sudo' this one).
    du [-s] *                   List disk usage of every subdirectory of the current directory (-s: summary).
    echo                        Print to Standard Out (StdOut)
                                -e: enable escape sequences; -n: suppress trailing newline;
    eject DEV                   Eject a device DEV to make it safe to remove (removes from /dev)
    file FILE                   Returns file type information about file FILE
    find DIR -name FILE -print  Prints the location of FILE if found in directory DIR
                                Note!  To use globs in the FILE, enclose them in single-quotes ''
    findmnt DEVICE              Print the mount point (if any) of DEVICE
    fg [PID]                    Continue a stopped process (optionally specify process id PID) in the foreground.
    free                        View current RAM and swap usage.
    grep PATTERN [file(s)]      Search for and print out all lines in file(s) matching PATTERN
                                -i: case insensitive; -n: print line numbers; -d skip: skip directories
    ifconfig [-a | -s | -v]     Show network InterFace connection information (like Windows ipconfig)
    kill PID                    Terminate a process by its process id (PID).
                                -STOP: pause a process; -CONT: continue after a pause.
    less FILE                   Read the contents of a long file FILE broken up into pages.
    ln -s TARGET LINKNAME       Create a symlink named LINKNAME pointing to TARGET
    logger [options] [message]  Send a log message. -p [facility.priority]: use specified facility.priority
    ls [DIR]                    List the contents of the directory DIR.  Defaults to current directory.
                                -l: 'long' format (more detail); -i: print inode numbers; -t: sort by modified time
    lsusb [-v]                  List the currently connected USB devices. -v: verbose
    md5sum FILE                 Compute and return the md5 128-bit checksum of file FILE.
    mount -t TYPE DEVICE DIR    Mount a DEVICE of type TYPE to the file tree at DIR.
    passwd [USERNAME]           Change the password for user USERNAME.  Defaults to current user.
    pkg-config                  Return metainformation about installed packages.
    ps                          List currently running processes.
                                x: only your processes; ax: all processes; u: more info; w: fulll command names
    pwd                         Print the working (current) directory
    read [var]                  Get user input in string form. Stores in 'var' if provided, else in $REPLY
                                -a: read as space-delimited array; 
    rmmod MODULE                Remove a module from the Linux kernel.
    route [FLAGS]               Display local routing table. -n: show raw IP addresses; -C: show routing cache
    set                         Allows you to set the values of shell options and positional parameters.
                                Calling bash with flag -a is the same as opening bash then calling 'set -a'
    seq [begin] [end]           Return a sequence of numbers from 'begin' to 'end'
    shasum [OPTIONS] [FILE]     Compute and return the SHA checksum value of FILE (or stdin if FILE is -)
                                -a [ALG]: use algorithm ALG (e.g. 256); -b: binary mode; -t: text mode (default)
    shutdown [OPTIONS] [TIME]   Cleanly shut down. -h: HALT (shutdown); -r: REBOOT; TIME = [now, hh:mm, +min]
    stat FILE                   Return a bunch of statistics about file FILE (including inode number, link count)
    stream                      Stream pixel data from one image source to a destination (very lightweight).
    sudo                        Do as superuser (requires password)
    systemctl                   systemd introspection and control
    tar                         Archive (zip) or unarchive (unzip) a file.
                                -z: zip; -c: create; -a: append
    tee [OPTIONS] [FILE]        Read from stdin; write to both stdout and to file 'FILE' (often used with pipe)
    tr a-z A-Z                  Translate standard input.  Swap all lowercase chars (a-z) in stdin with uppercase (A-Z)
    umount PATH                 Unmount the device at PATH
    uname                       Print system information
                                -o: OS; -m: machine; -a: all
    wc FILE                     Print the number of words, bytes, and newlines in FILE. -l: print newline count
    which FILE                  Returns pathnames of the files associated with FILE by searching $PATH
    whoami                      Returns the current username

Common Directory Structure:
    /
        /bin                    Compiled binaries and shell scripts, including basic Unix commands
        /boot                   Kernel boot loader files
        /dev                    Device files (see "Device I/O" below)
        /etc                    System configuration files, setup files, hardware drivers
        /home                   Personal directories for users
            /home/kpenney       My '~' directory.
        /lib                    Library files (shared) for executables
        /media                  Attachment point for removable media
        /opt                    A good place for 3rd party software
        /proc                   Provides a directory-like interface for processes
        /sys                    Device and system interface (see "Device I/O" below)
        /sbin                   System executables; related to system management; not generally for users
        /tmp                    Temporary workspace; many programs/users can use.
        /usr                    Poorly-named; basically like '/' and has similar subdirectories
            /usr/include        C header files
            /usr/local          A good place for admins to install custom software
            /usr/man            Man pages (alt. in /usr/share/man)
        /var                    System variables; runtime information; logging, caches
            /var/crash          Ubuntu puts crash reports here.  Delete them if they won't shut up.


File Permissions:
    File permissions can be viewed with a command like "ls -l" and normally show up as something like:
    -rw-r--r--      # A normal file with user read/write, group read, and other read permissions
    drwxr-xr-x      # A directory with user read/write/execute, group and other read/execute permissions.

    The first character is the file type.  Common file types:
        -           A normal file
        d           A directory
        l           A symlink
        b           Block device: a device which can be indexed for random access (e.g. hard drive)
        c           Character device: a device which interacts by read/write characters (e.g. serial port)
        p           Pipe device: an I/O stream to another process rather than a hardware driver
        s           Socket device: an IPC interface (e.g. Unix domain/BSD socket)

    The next 9 character are 3 groups of 3 characters each: user 'rwx', group 'rwx', other 'rwx'
    'user' is the current user (you). 'group' is the current user's group. 'other' is everyone else.
    If the letter is present, the permission is granted, otherwise the letter is replaced by a hyphen '-'

    chmod:
        To modify file permissions, use the 'chmod' command.  Examples:
            chmod u+x FILE      # Add execution permissions for FILE for the user.
            chmod g-w FILE      # Remove write permissions for FILE for the group.
            chmod go-rw FILE    # Remove read/write permissions for FILE for group and others.
            chmod 644 FILE      # Set user read/write, group/other read permissions for FILE.
            chmod 600 FILE      # Set user read/write, group/other none permissions for FILE.
            chmod 755 FILE      # Set user read/write/execute, group/other read/execute permissions for FILE.

        When you see 'chmod' used with numbers, it's like a bitmask in octal form.  The group of 9 letters is treated
        like a binary number written in octal form where each trio of letters is one octal digit.
        Example:
            rwx = 7
            --x = 1
            r-x = 5
            rw- = 6

        Options:
            -R                  --recursive
            -c                  --changes (report only when a change is made)
            --reference=RFILE   (use RFILE's mode as the mode values)

    umask:
        You can also specify a common file permission set to assign to all new files created during a session.
        'umask' takes the NEGATION of the 3-digit octal argument discussed in 'chmod' above (it's a MASK!).
        Example:
            umask 077           # All permissions for the user, none for group/other
            umask 022           # All permissions for the user, read/execute (no write) for group/other
        Note that it only applies to subsequently created files during a single session.

Shebang:
    Shebang scripts start with #! and are typically the first line of a file.
    These help a Unix-like OS identify the type of file or program associated with it.
    The Windows world uses only the file extension to determine the type, whereas Unix can alternatively use Shebangs

Symbolic Links (Symlinks):
    A symbolic link (symlink) is a file that points to another file or directory somewhere else on the disk
    (like a shortcut in Windows).
    You can see where a symlink points in the output of 'ls -l' (e.g. somedir -> some/other/dir)
    Symlinks can be confusing because their name does not necessarily say anything about the destination.
    In fact, the destination may not even exist!  This causes confusing output for programs trying to use
    the symlink.
    Also, the link can point to any type of file/directory (including another symlink!).

    ln -s:
        To create a symbolic link, make sure to use 'ln -s' (without the -s flag, you create a hardlink).
        Keep the syntax in mind:
            ln -s TARGET LINKNAME
        Reversing the order of the arguments can cause some very confusing results.

Archiving and Compression:
    tar:
        An archive is a bunch of files smooshed together into a single file.  The name 'tar' stands for "Tape Archive"
        as it was originally written for copying a directory structure to a tape drive.
        'tar' is used with a variety of flags to control its behavior.  The single-character flags can be concatenated
        and do not need to be preceded with a '-'.  This is why 'tar' is often followed by an opaque jumble of
        characters preceding the filename.

        Main Operation Mode:
        -c      Create a new archive
        -A      Append tar files to an existing archive
        -r      Append files to the end of an existing archive
        -t      List the contents of an archive
        -u      Only append files newer than copy in archive
        -x      Extract files from an existing archive

        Operation Modifiers:
        -z      Gzip compress after archiving
        -J      Use 'xz' compression.
        -a      Use archive suffix to determine the compression
        -p      Preserve archive's file permissions (--preserve-permissions, --same-permissions)

        Some flags require an argument; these must be at the end of the string of flags or should be used on their own
        or in their long form (see man(1) tar).
        
        -f FILENAME     Use the archive FILENAME
        
        Example:
            tar czf MyArchive.tar.gz FILE1 FILE2 FILE3  # Combine files into compressed archive MyArchive.tar.gz
            tar xzf MyArchive.tar.gz                    # Extract files from existing archive MyArchive.tar.gz

    gzip:
        GNU zip (gzip) is a file compression tool.  It takes as its input a single uncompressed file, and outputs
        a compressed file, appending the '.gz' extension.
        To unzip, a separate command name 'gunzip' is used.  Example:
            gzip FILENAME       # zip FILENAME to FILENAME.gz
            gunzip FILENAME.gz  # unzip FILENAME.gz to FILENAME

File I/O:
    Unix allows many modes of file interface (some described above).  Here are some helpful programs/commands
    to make file I/O easier.

    dd:
        'dd' reads from an input file and writes to an output file.  It's helpful for both file and device I/O.
        Since 'dd' will read/write whatever you give it, it's easy to mess up and corrupt a file.  Be careful!
        The 'dd' syntax comes from IBM Job Control Language, so it's a little wonky. Example:
            dd if=/dev/zero of=my_new_file bs=1024 count=1

        Arguments:
            'if' is input file
            'of' is output file
            'bs' is block size (how many bytes to write per file operation).  The 'bs' argument can also use
                 key-letters 'b' = 512 and 'k' = 1024 instead of pure bytes
            'ibs' and 'obs' are the input block size and output block size if different (if same, use 'bs')
            'count' is the total number of blocks to copy
            'skip' is the number of blocks in the input file to skip past before copying
 
Device I/O:
    In the Unix world, the kernel presents a user-space interface to a device to make it accessible to the user.
    This interface can take a variety of forms based on device functionality or historical legacy.
    Devices are assigned a major number and a minor number which help identify the device.  These can be found in
    several places including '/proc/devices' and 'ls -l /dev'

    Device Files (/dev):
        Many devices have simple interface files which provide file-like I/O operations (e.g. read/write/seek) to
        the user while the kernel and device drivers handle the translation to the device's API.
        These device files are typically found in the directory /dev.
        Example: to write characters to a character device, you can simply redirect from StdOut.
            echo Hello Device! > /dev/null
            # /dev/null is a bin-bucket (write-only memory, black hole, etc...)

    Common Devices and Naming Conventions:
        /dev/sd*        Hard disk drives
        /dev/sr         CD/DVD drives
        /dev/hd*        Hard disk drives using PATA legacy compatibility (check BIOS to switch to SATA)
        /dev/tty*       Terminals and virtual terminals
        /dev/pts/*      Pseudoterminals
        /dev/tty        The controlling terminal of the current process
        /dev/ttyS*      Serial ports (Windows COM1 would be /dev/ttyS0, COM2 would be /dev/ttyS1, etc.)
        /dev/ttyUSB*    USB-to-serial adapters.  Also show up as /dev/ttyACM*
        /dev/lp*        Parallel ports (old school DB25 style).  Can interface directly with cat > /dev/lp0
        /dev/snd/*      Audio/sound devices (part of the "Advanced Linux Sound Architecture" (ALSA) system)
        /dev/dsp        A legacy sound device interface (see "Open Sound System")

    sysfs Device Path (/sys/devices):
        For many devices, a simple device file interface does not allow exploitation of the device's full
        capabilities.  For this reason (and others), an alternate interface is often provided with a sysfs
        device path.
        The actual sysfs device path can be stupidly long and unintelligible, but helpful symlinks are normally
        provided to find the actual interface path (e.g. /sys/block contains symlinks to all block devices).
        You can also use 'udevadm' to find the device path (see below).

    udev and devtmpfs:
        In the past, new Linux versions would add device compatibility and assign new maj/min numbers which
        would break the /dev filesystem. Then /dev would thus have to be rebuilt for every new release.
        To simplify this process, 'udev' and 'devtmpfs' were created.

        devtmpfs:
            The 'devtmpfs' filesystem is implemented via a collection of kernel-space and user-space programs
            and daemons which keep the hardware, device files, and device paths synchronized.
            Because the kernel needs device files early in the boot process (before 'udev' can start), the
            job of maintaining the 'devtmpfs' filesystem is split between kernel-space and user-space programs.
            Simple example:
                New hardware is detected by the kernel.
                The kernel sends a 'uevent' notification to 'udevd' with the device's attributes.
                'udevd' loads all the attributes and consults its rules to determine actions to take.
                    Default rules are in /lib/udev/rules.d, overrides are in /etc/udev/rules.d
                'udevd' creates symlinks in /dev and elsewhere and does other stuff based on the rules
                and device attributes. 
        udevadm:
            To query device details, the 'udevadm' command is very helpful.  Example:
                udevadm info --query=all --name=/dev/sda
        
            The above command returns a bunch of information (looks like a Windows registry).  The sysfs device
            path follows "DEVTYPE=".

            To monitor 'uevent' events coming from devices, use 'udevadm monitor'.  Example:
                udevadm monitor --kernel
                # Returns only kernel events

    Mounting a Filesystem Device:
        After attaching a new block device (assuming it's already been formatted), you need to first mount the
        filesystem at a chosen path before you can interface with the new block device.
        For example, if I plug in a new USB stick (say 16GB vfat), the new device may show up in /dev as
        something like "/dev/sdc1" (use fdisk -l and/or udevadm to find the device).
        Then I can mount it to a particular location like this:
            sudo mount /dev/sdc1 /media/kpenney/myUSB16GB

        The directory you mount to can be anything you wish.  Common mount points are /mnt, /media/mnt, etc.
        When you're ready to remove the device, use 'umount' and 'eject':
            sudo umount /media/kpenney/myUSB16GB
            sudo eject /dev/sdc1

        To make a permanent association between a device and a mount point, we add a line to our /etc/fstab file:
            /dev/sdc1                       /media/kpenney/myUSB16GB    vfat    defaults    0   0
            /dev/disk/by-uuid/8675-3090     /media/kpenney/myUSB16GB    vfat                0   0

        In the second example, we used the device's UUID since different devices might show up at /dev/sdc1.
        If the device doesn't mount automatically, you can use "mount -a" to mount all unmounted devices.

        mount options:
            -o [fs-option]              # Specify a filesystem-specific option
            -r                          # Mount as read-only
            -n                          # Do not update runtime mount database /etc/mtab (useful at boot time)
            -t [fs-type]                # Specify a filesystem type.  Sometimes 'mount' can guess correctly.
            [The following options must all follow a -o flag]
            exec/noexec                 # Enabled/disables program executions on the filesystem
            suid/nosuid                 # Enables or disables setuid programs.
            ro                          # Mount as read-only (same as -r above)
            rw                          # Mount as read/write
            conv=RULE                   # Convert newline characters (e.g. for FAT) based on RULE=binary/text/auto
            remount                     # Remount a filesystem (see below).

        Remounting:
            There are times when you'll need to remount a filesystem (e.g. after a change to /etc/fstab).
                mount -n -o remount /   # Remount the main filesystem at / (root).
            This assumes the device is listed in /etc/fstab.  If not, you must specify the device.

    Unmounting:
        Modern operating systems buffer disk operations in a cache to speed up the user interface and minimize
        costly writes to the disk.  But this means that even after completing all write tasks, a filesystem device
        has not necessarily received the bytes (e.g. they could still be in the cache).  This is rare, but it's
        good practice to do the following before disconnecting a filesystem device:
            umount /dev/mydevice        # Detach the device from its mount point
            sync                        # Ensure all cached write operations are completed
            eject /dev/mydevice         # Finally remove /dev/mydevice from the device table

    Example:
        Seagate USB 3.0 1TB Expansion Drive on kpenney-z97:
        $ udevadm info ...
            /dev/disk/by-id/usb-Seagate_Expansion_NA82B35X-0:0-part1
            /dev/disk/by-path/pci-0000:00:14.0-usb-0:3.1:1.0-scsi-0:0:0:0-part1
            /dev/disk/by-label/Seagate\x20Expansion\x20Drive
            /dev/disk/by-uuid/643EE23A3EE204C0
            /dev/sdb1

        $ findmnt /dev/sdb1
            TARGET                                  SOURCE      FSTYPE  OPTIONS
            /media/kpenney/Seagate Expansion Drive  /dev/sdb1   fuseblk rw,nosuid,nodev,relatime,user_id=0...

Partitions:
    The first block of memory on a disk is reserved for the partition table.  There are two primary types of
    partition tables: Master Boot Record (MBR) and Globally Unique Identifier Partition Table (GPT)
    
    Primary partition:  A normal partition of the disk.  Normal MBR supports up to 4 of these.
    Extended partition: A partition beyond the normal 4 primary partitions.
    Logical partition:  An extended partition is broken up into logical partitions.

    View Partitions:
        parted      A text-based partitioning tool that supports both MBR and GPT.
        gparted     A graphical version of 'parted'
        fdisk       A text-based partitioning tool that supports only MBR.
        gdisk       A version of fdisk that supports GPT, but not MBR.

        parted -l           View current disks and partitions.  Output depends on the partition table type:
                            Number  Start   End Size    Type    File System Flags   // for MBR (aka 'msdos')
                            Number  Start   End Size    File System Name    Flags   // for GPT

        fdisk -l            List disks and partitions and exit (rather than entering interactive mode).
                            Device  Boot    Start   End Sectors Size    Id  Type

        Note: if you see a kernel message like: "sda: sda1 sda2 < sda5 >", it means sda5 is contained within
        sda2 (sda2 is most likely an extended partition).

    Modify Partitions:
        There's a key difference between the operation of parted/gparted and fdisk/gdisk.
        While 'fdisk' will only modify the partition table when you perform a "save and exit", allowing you to
        view and modify your desired configuration before any changes are made, 'parted' makes changes to the
        partition table immediately as you execute commands.  This makes it very easy to mess up with 'parted'
        where 'fdisk' is a bit more forgiving.

    Paritions and Disks:
        On older hard disk drives, it was critical for performance to ensure your partitions lined up with cylinder
        boundaries on the disk itself and each partition was made of contiguous cylinders.  Modern disk drives
        implement a more user-friendly architecture than ensures partitioning is optimized for performance.
        Solid state drives don't have cylinders (obviously), but they do perform reads in big chunks (e.g. 4096 bytes)
        so if partition boundaries don't line up with these chunks, small disk operations (like directory reads) can
        take extra time by requiring two reads instead of one.
        parted/gparted has utilities that ensure your partition alignment is optimized.

Filesystems:
    A filesystem is what turns a simple block device into a hierarchy of files and directories; without it a block
    device is simply a continuous chunk of memory with poorly defined boundaries (if any).
    Originally designed simply to provide a navigable interface to a data storage medium, filesystems have evolved
    to incorporate a variety of other features like system interfaces.

    Virtual File System (VFS): a standardized abstraction layer for filesystem interfaces.  With VFS, user-space
    programs can interface with many different filesystems in a uniform manner.

    File system in USEr space (FUSE): allows user-space filesystems in Linux.  Most filesystems are implemented in
    the kernel and require kernel calls to interface with user-space programs.

    Fourth Extended Filesystem (ext4):
        The latest (as of 2018) iteration of a line of filesystems native to Linux.  ext2 was based on the Unix
        File System (UFS) and the Fast File System (FFS) and was a longtime standard for Linux systems.
        ext3 added a journal feature which improved data integrity and sped up the boot process.
        ext4 added support for larger files and deeper directory trees.
        Note: ext2 and ext3 can be mounted as ext4, but ext4 cannot be mounted as either ext2 or ext3.
        Note: new filesystems are being developed for Linux - see 'btrfs'
    
    FAT filesystems (msdos, vfat, umsdos):
        These are Microsoft's native filesystems.  'msdos' is the name given to anything FAT32 or prior.
        The msdos system (aka FAT32), does not distinguish between cases (upper/lowercase) for file/directory names.
        The vfat system supports long filenames, journaling, new encryption algorithms, hardlinks.
        The umsdos system is an oddball msdos system with Unix features added on.
        Of course, all modern Windows systems use NTFS filesystems.  Unix has free drivers available for NTFS.

    HFS+ (hfsplus):
        HFS+ is an Apple filesystem that improves on the older HFS and is used on most Apple/Macintosh devices.
        It supports long filenames, journaling, hard links, etc.
        It is beginning to be replaces by the Apple Filesystem (APFS) as of 2017.

    ISO 9660 (iso9660):
        This is the standard filesystem for CD-ROM.

    Special-Purpose Filesystems:
        Unix has implemented several instances of using a filesystem to serve as a type of system interface,
        rather than representing data stored on a physical device somewhere.  Here are some examples:

        proc:
            Mounted on /proc
            Each numbered directory in /proc is the process ID of a current process on the system.
            The files within each subdirectory represent different aspects of the process.

        sysfs:
            Mounted on /sys
            Allows for a more elaborate device interface than the simple /dev location.

        tmpfs:
            Mounted on /run (and other locations).
            Allows using physical memory as a temporary file storage location.

    View Currently Mounted Filesystems:
        The command 'df' will list all currently mounted filesystems, their available space, used space,
        device name, and mount point.
        The command 'du' will list the disk usage of every directory in the hierarchy, walking the tree from
        your current directory.  This output can be verbose.  Try using 'du -s' for a summary instead.

    Making a Filesystem:
        Once you've installed a new disk/drive and properly formatted its partitions, you're ready to create a
        filesystem on the drive.  The 'mkfs' command (which actually redirects to another program based on the
        target filesystem) is an easy user-space command for this job.
            mkfs -t ext4 /dev/sdf2      # Assuming the device is at /dev/sdf2 and you want an ext4 filesystem
            mkfs.ext4 /dev/sdf2         # This is called by mkfs (equivalent)
            mke2fs -t ext4 /dev/sdf2    # This is called by mkfs.ext4 (so much abstraction!)

        Any of the above commands can be called to do the same job; they're equivalent.  Any options not specified
        in the command are controlled by defaults stored in /etc/mke2fs.conf

    Mounting a Filesystem:
        The last step to adding a disk/drive is to mount your newly created filesystem using 'mount'.
        See "Mounting a Filesystem Device" above.
            mount -t ext4 /dev/sdf2 /home/newdrive      # Assuming /home/newdrive is your desired mount point
            mount UUID=5ac31dba-f30b-801a-e4ca-3ldf0076fdee /home/newdrive  # You can find your UUID with 'blkid'

    The Filesystem Table (/etc/fstab):
        Linux keeps a permanent list of filesystems and mount options to automatically mount on bootup.
        The devices, mount points, and mount options are listed in a simple plaintext file '/etc/fstab'.
        Each line corresponds to one filesystem and has the following structure.
            dev/UUID    mount-point     fs-type     options     backup-info     fs-test-order

        'options' are a list of long options (see 'mount options' above) separated by commas.
        'backup-info' should always be zero '0' (used by the 'dump' command).
        'fs-test-order' should be 1 for the root filesystem, 2 for other filesystems, and 0 for everything else

    Checking and Repairing a Filesystem:
        The kernel trusts the filesystem completely (assumes no errors).  Errors in the filesystem can result
        from unexpected power outages, disk failures, improper device unmounting, etc.
        Modern filesystems which use journaling are far less prone to filesystem errors, but checks should
        still be done periodically.  This can be done with command 'fsck' (FileSystem ChecK).

        Warning!  Only run fsck on an unmounted device as the kernel could otherwise alter the disk data while
        the check is running.  The only exception is with the root partition mounted in read-only single-user mode.
            fsck /dev/sdb1              # Run fsck on device /dev/sdb1 in interactive manual mode

        In interactive manual mode, fsck will stop on an error and ask you how you would like to proceed.
        If fsck encounters a "loose inode", it has found a file that appears to have no filename.  These files
        are collected in the "lost+found" directory for manual renaming by the user.

        fsck flags:
            -p          # Automatically fix common errors
            -a          # Same as -p
            -n          # Check the filesystem without modifying anything
            -fy         # e2fsck only!  Flush the journal to the filesystem database.  
                        # The kernel will not mount a filesystem with a non-empty journal.

        Worst-Case Scenario:
            If the filesystem is really messed up, try one of the following:
                Use 'dd' to copy the entire filesystem to another partition of the same size.
                Repair (as much as possible) and mount the filesystem in read-only mode and copy data manually.
                Use 'debugfs' command (which pretty much just does the above option).

    Swap Space:
        If you run out of physical memory (RAM), the Linux virtual memory system can make use of the disk by
        moving pieces of memory to and from a reserved section of the disk called "swap space."
        Normally only blocks of memory associated with idle programs are "swapped" to the disk.
        Use the command 'free' to view the current swap usage.

        Using a Disk Partition as Swap Space:
            To use an entire disk partition as swap space:
                1. Ensure the partition is empty.
                2. Run "mkswap DEVICE" (where "DEVICE" is the partition's device path).
                3. Run "swapon DEVICE" to register the space with the kernel.
                4. (optional) Add an entry to /etc/fstab to use the partition as swap space on bootup.

        Using a File as Swap Space:
            If you would rather not repartition a drive to make some swap space, you can use a normal file.
            To do so, run the following with "SWAPFILE" as the name of the new file to use as swap space and
            "NUM_MB" the file size in megabytes (MB).
                dd if=/dev/zero of=SWAPFILE bs=1024k count=NUM_MB   # Recall /dev/zero is a source of zeros
                mkswap SWAPFILE
                swapon SWAPFILE

        To remove a file or partition from swap space, use "swapoff DEVICE".

    Structure of a (Traditional Unix) Filesystem:
        Traditional Unix filesystems are made up of a section of data blocks and a database system that manages
        the connections between the data blocks.  Note that even if new filesystems don't operate in this manner,
        the Unix Virtual FileSystem (VFS) ensures that programs that expect this kind of interaction can still
        function on them without too much modification.

        Inodes:
            An inode is a set of data that describes a file.
            Includes filename, type, permissions, and a pointer to the top of the file in the data blocks.
            Inodes are assigned numbers (inode numbers) and are appended to the "inode table" for lookup.
        
        Link Count:
            Each inode has an associated link count.  This is the number of pointers that reference it.
            Each time a pointer is created to reference the inode (e.g. a hardlink), the link count is
            incremented.  Each time one of those pointers is deleted (removed), the link count is decremented.
            When the link count reaches 0, the Kernel can overwrite the data at that data block.
            Note: the link count of directories tends to be >1 because each subdirectory has a '..' link
            to its parent directory.

        Viewing Inode Details:
            The 'stat' command shows a file's inode number, link count, and various other details.
            The '-i' flag of command 'ls' shows the inode number for each entry in the directory.

        Block Bitmap:
            The block bitmap is a series of reserved bytes with each bit representing a block of memory.
            A '0' at a bit means its corresponding memory block is free for writing, a '1' means it's in use.

Job Control:
    You can pause a process by pressing "Ctrl+Z" during operation.
    Once paused, a process can be sent to the background with 'bg' or brought to the foreground with 'fg'
    You can immediately cast a process into the background with the ampersand "&".  Example:
        gunzip myFile.gz &
    This will print the process id and then immediately return you to the prompt, running 'gunzip myFile.gz'
    in the background.
    Note that it might be helpful to redirect output to a file so that it doesn't bug you from the background.
    Also note that if the program waits for user input (like paging with 'less'), it will wait indefinitely in
    the background.

The Boot Process:
    A simplified summary of the stages of the Unix boot process:
    1. The computer's BIOS or boot firmware loads and runs a boot loader.
    2. The boot loader finds the kernel image on a disk, loads it into memory, and starts it.
    3. The kernel initializes the devices and their drivers.
    4. The kernel mounts the root filesystem.
    5. The kernel starts the "init" program with a process ID of 1.  This point is the "user space start."
    6. "init" starts the rest of the system processes.
    7. "init" starts a program that allows the user to log in.

    Startup Messages:
        During the boot process, the BIOS, Kernel, and system processes will spit out a whole bunch of
        text (some of which may even be informative).  Since this happens so fast, and a lot of it is
        hidden from the user, it's best to view these messages after the boot.
        These messages are often written to the kernel system log file (/var/log/kern.log)
        Or you could look at the output of 'dmesg' (remember to pipe to 'less' or 'grep').

        Once the user space startup procedure kicks off, messages are not stored in a single log, but each
        process typically writes its own log somewhere.  Some versions of 'init' can log all startup messages
        if you don't want to hunt around through a bunch of logs.

    The Bootloader:
        The computer's BIOS (or UEFI) is the first firmware to wake up and has only simple capabilities
        hardwired in non-volatile memory.  The first thing it does is load and run a bootloader.
        The bootloader needs to know how to find the kernel and what parameters it should pass to it.

        To do this, it needs to access the disk.  Without the kernel, disk access must go through the BIOS
        and is thus quite limited.  BIOS knows how to access nearly any disk hardware via Linear Block
        Addresing (LBA) which is slow but universal and gets the job done.

        Once the bootloader can actually read bits from the disk, it needs to know how to traverse the
        filesystem to find the kernel - this capability must be preprogramed into the bootloader.  Thus
        if a bootloader encounters a filesystem that it doesn't recognize, it cannot boot the kernel from it.

        Kernel Parameters:
            Kernel parameters are parameters passed by the bootloader to the kernel upon startup.
            If the Kernel receives a parameter it doesn't understand, it saves it and passes it to 'init'
            once it's started.
            You can view these parameters at: /proc/cmdline

            root=...        # This is the location of the root filesystem.  Can be /dev/... or UUID
            BOOT_IMAGE=...
            ro              # Mount the root filesystem as read-only upon user-space start (to run fsck)
            splash          # Hide boring startup output with a classy splash screen

        Bootloader Configuration:
            If a bootloader were to only have a single set of preprogrammed capabilities, it would not
            be terribly useful.  Thus, all bootloaders can be configured to some degree.  Some of their
            capabilities:
                - Select between multiple kernels
                - Switch between sets of kernel parameters
                - Allow manual user override of kernel image names and parameters
                - Provide support for booting other operating systems

            Modern advances have diminished the need for some of these capabilities (e.g. booting from a
            USB flash drive instead of into single-user mode), but it is still necessary at times to
            change bootloader configurations.  This requires getting to the boot prompt, a process which
            varies substatially between distributions.

            One of the most popular Linux bootloaders is called GRUB.  Some other common bootloaders
            include: LILO, SYSLINUX, LOADLIN, coreboot (aka LinuxBIOS) for BIOS
            and:     efilinux, and Linux Kernel EFISTUB for UEFI.

        GRUB (aka the GRand Unified Bootloader):
            Note!  The following applies to "GRUB 2", rather than the older "GRUB Legacy".
            To access the GRUB configuration,
                - Hold down the SHIFT key during the BIOS boot process to bring up the GRUB menu
                - This will bring up a window with simple boot options.
                    - Press Esc to disable the automatic timeout
                - Press 'e' to view/edit the defaul bootloader configuration commands

            GRUB Configuration:
                The GRUB configuration parameters screen looks confusing for a reason: GRUB has its own
                kernel and borrows a lot of terminology from the Unix world.  A lot of things on this
                screen will look familiar but may not be the process/file you're familiar with.
                Look at the kernel parameters for anything related to the kernel (including the root path).
                Every reference to 'root' outside of the kernel parameters line is referencing the GRUB root.
                Editing the configuration here will affect only the current boot.

                gfxmode         # Graphics mode
                insmod          # Insert a module or device driver (like the Linux 'insmod')
                set root=...    # Set the GRUB root (not the kernel root)
                search          # Search the grub root for the kernel boot image
                linux           # Load the Linux kernel image file from the GRUB root
                initrd          # Load the file for the initial RAM filesystem

                grub.cfg:
                    GRUB configuration options are stored in /boot/grub/grub.cfg but the file should not
                    be modified directly; instead it is automatically generated/modified by several commands
                    including 'grub-mkconfig'.
                    'grub-mkconfig' builds grub.cfg out of various shell scripts in /etc/grub.d
                    To add a new custom configuration, you can create a new '.cfg' file (best to use a template)
                    then add it with: grub-mkconfig -o /boot/grub/grub.cfg

            GRUB Command Line:
                From the boot menu or configuration editor, press 'c' to open the GRUB command line.
                Simple commands:
                    ls              # Lists the installed devices currently known to GRUB
                                    # Disk drives are labeled hd0, hd1, etc...
                                    # 'msdos' means an MBR partition (rather than a GPT).
                    ls -l           # Lots more output.  Includes device UUID and filesystem type.
                    echo $root      # Return the GRUB root (where it expects to find the Kernel)
                    ls ($root)/     # List contents of the GRUB root
                    ls ($root)/boot # List contents of the /boot directory in the GRUB root
                    set             # List currently defined GRUB variables (like CMD)
                    boot            # Execute the current boot configuration

        Bootloader Summary:
            Bootloaders can be configured to boot in two very different ways:
            MBR Boot:
                The Master Boot Record (MBR) contains a tiny dedicated area (441 bytes) which the BIOS
                loads and executes.  Since this is pathetically small, this code just loads the bootloader
                from a section of memory between the MBR and the first partition on the disk.

            UEFI Boot:
                The problem above with MBR boot helped motivate the development of the Unified EFI (UEFI)
                standard.  UEFI includes fancy features like a built-in shell and the ability to read and
                navigate partitions and filesystems.  In this case there is always a separate small partition
                on a disk called "ESP" which contains an 'efi' directory with subdirectories corresponding
                to each bootloader available on the system.
                To use UEFI Boot with GRUB, you must install the UEFI version of GRUB (not the BIOS version)!

    Common "init" Versions:
        The "init" program is responsible for loading all the processes that user-space requires at startup
        in a logical manner so that all dependencies and conflicts are resolved.  It should optimize for
        speed and minimal resource usage.

        In the past, "init" was not much more than a fancy shell script with a pre-defined order that
        processes are to be called, but it has evolved into much more elaborate schemes to meet the demands
        of modern systems.

        System V init:
            System V introduced the concept of a "runlevel" which, though not of consequence in modern machines,
            has stuck around as a sort of artifact that you see every once-in-a-while.  The runlevel is a number
            between 0 and 6.  The system spends most of its time in one runlevel (corresponding to user-space),
            but switches levels to cleanly startup or shutdown processes or the system itself.
        Upstart:
            Upstart is an event-driven "init" incarnation in use in Ubuntu systems before version 15.04
        systemd:
            systemd is a relatively modern version of init.  Under systemd, each process is represented by
            a "unit file" which describes the process and specifies what it requires to operate and what it
            may conflictvwith.  The desired configuration is described as a "goal" to be acheived. It is then
            the responsibility of "init" to decide how to achieve the "goal".

            Configuration:
                systemd configuration files are spread all over the place.  Two typical directories are:
                [/usr]/lib/systemd/system           # System UNIT directory
                /etc/systemd/system                 # System CONFIGURATION directory

                To check the current systemd configuration search path, use the 'systemctl' command:
                    systemctl -p UnitPath show

                You can also use 'pkg-config' to show the system unit/configuration directories:
                    pkg-config systemd --variable=[systemdsystemunitdir, systemdsystemconfdir]  # one or the other

            Unit Files:
                The syntax of unit files comes from the XDG Desktop Entry Specification (commonly used with ".desktop"
                files).  The unit files fall into three categories.

                Service units:  controls the traditional Unix service daemons.
                                ".service" extension with a "[Service]" section
                Mount units:    controls the attachment of filesystems.
                                ".mount" extension with a "[Mount]" section
                Target units:   controls other units, usually as groups.
                                ".target" extension with a "[Target]" section

                Dependencies:
                    Requires            Strict dependencies; the unit is deactivated if a "requires" fails.
                    RequiresOverridable Behaves like "Requires" when run normally and "Wants" when started manually.
                    Wants               Activation only; if a "wants" fails after activation, unit not affected.
                    Requisite           Already active; if a "requisite" is not active, unit activation fails.
                    Conflicts           systemd deactivates "conflicts" if they are active when the unit is activated.
                    Before=...          systemd activates the unit before the argument of "before"
                    After=...           systemd activates the unit after the argument of "after"

                    Conditional Dependencies:
                        ConditionPathExists=p           True if the file path 'p' exists
                        ConditionPathIsDirectory=p      True if 'p' is a directory
                        ConditionFileNotEmpy=p          True if 'p' is a file of nonzero length

                    To view dependencies of a particular unit, use the 'systemctl' command:
                        systemctl show -p type unit

Shutting Down:
    'init' also controls how your system shuts down.
    To properly shutdown a Linux system, use the 'shutdown' command.  Examples:
        shutdown -h now                 # Shutdown and halt (power off) now
        shutdown -r +10                 # Shutdown and reboot in 10 minutes
    'shutdown' tells 'init' to begin the shutdown process.
    Depending on your version of 'init':
        systemd activates the shutdown units
        Upstart emits a shutdown event
        System V changes runlevel to 0 or 6.

    Shutdown steps:
        'init' asks every process to shut down cleanly
        If a process doesn't respond after a time, init tries to kill it with a TERM signal
        If the TERM signal doesn't work, init uses the KILL signal.
        System files are locked into place (no more read/write/open)
        System unmounts all filesystems other than the root fs.
        System remounts the root fs as read-only.
        System writes all buffered data out to the fs with the 'sync' program.
        Someone (either 'init' or someone else) sends the 'reboot' system call.

System Logging:
    Most system processes spit all their chatter to the 'syslog' service for system logging.  The traditional
    logging service is some version of the 'syslogd' daemon.  The system logger waits for messages and routes them
    all over the place, based on configuration settings.  Most of the messages end up in some sort of log file.

    rsyslogd:
        Most moder distributions use 'rsyslogd' which is a suped-up version of 'syslogd'.
        Configuration:
            /etc/rsyslog.conf
            /etc/rsyslog.d
        syslogd configuration files are made up of 'rules' and some program-specific extentions (e.g. 'rsyslogd')
        A traditional 'rule' has a 'selector' and an 'action' to show how to deal with particular log types.
        The selector is a pattern that matches the 'facility' and 'priority' (facility.priority) of log messages.
        The 'facility' is a general category of message (see man 5 rsyslog.conf).
        The 'priority' is one of (lowest to highest): 
            debug, info, notice, warning, err, crit, alert, emerg
        The specified priority is the lowest caught; will also catch all higher priorities.
        
        Example:
            #selector               #action                 #note
            kern.*                  /dev/console            #Send 'kern' facility msgs to the 'console' device file
            *.info;authpriv.none    /var/log/messages       #A priority of 'none' excludes messages from the facility
            authpriv.*              /var/log/secure,root    #'root' means send the msg to the superuser if logged in
            *.emerg                 *                       #An action of '*' means send to all logged-in users
        
        Directives:
            Anything beginning with a '$' is a directive, an extension to the original 'syslogd' syntax.
            There are many directives.  Here are some examples:

            $IncludeConfig /etc/rsyslog.d/*.conf            # Include all .conf files in /etc/rsyslog.d as config files

    Testing the Logger:
        The 'logger' command sends a log message manually.  This is a good way to test your logging configuration.
        E.g.:
            logger -p daemon.info Hi Keith, how\'s it going?
            # Send "Hi Keith, how's it going" with facility.prioirty = daemon.info

User Management:
    To the kernel, users are just numbers (user IDs).  In user space, a username is associated with a user ID.
    The mapping of a username to a user ID is done in /etc/passwd
    When an account is created on a Linux OS, it creates an entry in /etc/passwd and a home directory.
    
    /etc/passwd
        This file contains more than just mapping from username to user ID.  Fields are separated by colons :
        See "man 5 passwd"
        username : encrypted password : user ID : group ID : real name : home : shell
        
        The encrypted password is often stored in the "shadow file" (/etc/shadow) instead of /etc/passwd.  If this
        is the case, there is typically an 'x' in the "encrypted password" field.  An asterisk '*' in this field
        means the user cannot log in.
        The user ID should be unique.  This is how the kernel identifies a user.
        The group ID is one of the numbered entries in the /etc/group file.  Primarily for file permissions.
        The 'real name' field can contain multiple entries separated by commas.  Often called the GECOS field.h
        The 'home' field specifies this user's home directory.
        The 'shell' field specifies this user's preferred shell program.

        Special Users:
            Special users listed in /etc/passwd include:
            superuser: always has UID 0 and GID 0. Full privileges.
            daemon: no login privileges
            nobody: no write privileges; often programs run as this user for security reasons.

        Manipulating /etc/passwd
            Don't edit this file directly.  Instead, use the built-in utilities:
            passwd                              Change the user's username
            adduser [options] USER GROUP        Add a new user USER under group (possibly new) GROUP
            useradd                             A lower-level utility for when 'adduser' is not available.
            deluser [options] USER GROUP        Delete a user and/or group.
            userdel                             A lower-level utility for when 'deluser' is not available.
            addgroup
            delgroup
            usermod -a -G GROUP USER            Add an existing user to an existing group.

            If you really need to edit this file, use 'vipw' which will make a locked backup copy during editing.

        To view information about the users and groups defined on a system, use these commands:
            users                               List the currently logged-in users
            groups                              List the groups associated with the current user.
            id USERNAME                         View the UID, GID, and groups associated with USERNAME

    /etc/shadow
        This file replicates many of the features of /etc/passwd but in a more secure format.
        There is a suite of libraries and utilities (mostly owned by PAM) to manipulate this file.

    /etc/group
        Groups are less important now that fewer machines are used by several people.
        Groups are almost entirely used for controlling file access permissions.
        Entries in /etc/group are also fields separated by colons ':'
        group name : group password : group ID : userlist
        
        group name: A human-readable group name
        group password: don't use this.  Just put an asterisk '*' here.
        group ID: The number the kernel associates with the group name.
        userlist: a comma-separated list of users belonging to this group (optional).

    getty and login:
        'getty' is a program that attaches to a terminal and displays a login prompt.
        After a username is entered, 'getty' replaces itself with 'login' which prompts for a password.
        If the password is entered correctly, 'login' replaces itself with your preferred shell.
        This is less commonly used now; just fyi.

Time and Scheduling:
    The kernel maintains the 'system clock' which is the clock that timestamps processes and logs.
    The motherboard has a battery-backup hardware RTC which is fairly accurate.  The system clock is set to
    the value of the hardware clock at bootup, but is typically updated by a network service daemon.
        hwclock --systohc --utc         # Update the hardware clock based on the system clock in UTC

    Network Time Protocol (NTP):
        An NTP daemon periodically updates the system clock based on that of a nearby network server.
        This service is provided by http://www.ntp.org/
        Utilities like 'ntpdate' and 'nptd' provide an interface to this service.

    Scheduling Tasks with cron:
        The utility 'cron' is used for scheduling tasks.  It is the most commonly used Unix daemon for scheduled
        tasks like system maintenance and log file rotation.
        'cron' works by executing a 'cron job' specified in the 'crontab' file at the scheduled time.
        If the process generates standard output or an error an exits abnormally, I guess you get an email?
        Redirect this output to /dev/null to ignore it.

        cron jobs:
            To add a 'cron job' to the 'crontab' file, it's best to use the 'crontab' command.

            Structure of a cron job:
                The fields of a cron job entry are space-separated.  To denote all possible values (e.g. all days
                of a month), enter an asterisk '*' in the field.
                Each entry can also be a comma-separated list.

                (minute: 0-59) (hour: 0-23) (day of month: 1-31) (month: 1-12) (day of week: 0-7) (command)

                day of week:    both '0' and '7' represent Sunday
                command:        the command to be executed.

        crontab Files:
            Each user can have its own crontab file.
            The simplest way to install a new crontab file is to put your crontab entries into a file and use
            'crontab FILE' (where FILE is that filename) to install it as your current crontab file.
            The 'crontab' command checks the syntax of the file.
                crontab FILE    Add FILE as the current crontab file.
                crontab -e      Edit your current crontab file with the editor specified by VISUAL/EDITOR envars
                crontab -l      List all cron jobs in crontab file.
                crontab -r      Remove the current crontab file.

            System crontab Files:
                For system tasks, there is a file (or directory) /etc/crontab (/etc/cron.d) with a slightly
                different syntax which includes the user before the process.
                Don't use crontab to edit these files.

    Scheduling a Single Task with 'at':
        Note: 'at' is not installed by default on Ubuntu
        To schedule a single, non-recurring task sometime in the future, you can use the command 'at'
            at TIME             # Start defining a command to execute at time TIME = [HH:MM] or [HH:MM DD.MM.YY]
                                # After hitting Enter, you will see 'at>' prompting for the command to execute.
                                # End entry with Ctrl+D
            atq                 # Check for pending scheduled commands
            atrm                # Remove a scheduled command

Networking on Unix:
    For general networking notes, see TCP/IP notes.
    When a routine wants to send a packet to a destination on the network it first consults the routing
    table and routing cache to determine which (if any) network adapter is needed for the destination.
    This information is stored locally in the routing table (and the routing cache).  Most users will find
    these tables to be pretty sparse, but they will list any destinations on your local network as well
    as proxy servers and your local router(s).

    The 'route' command allows viewing/modifying the routing table and the routing cache.
        route                   # display the route table
        route -n                # display the route table in raw IP addresses (no name resolution)
        route -Cn               # display the route cache w/o name resolution

    The output of any of the above uses of the 'route' command will list these columns:
        Destination Gateway Genmask Flags   Metric  Ref Use Iface

    When the internet protocol (IP) receives a target IP address, it compares it to each entry in these
    tables by bitwise AND'ing the 'Genmask' and the 'Destination'.  If it is a match, the packet is
    directed towards the 'Gateway'. The 'Iface' is the physical (or virtual) network adapter (interface)
    used for that gateway.  See 'man route' for the other columns.

    Recall that the default gateway (0.0.0.0) is used whenever no matches are found in the routing table.

    Since the physical hardware transporting network traffic doesn't understand IP addressing, software
    must translate between IP addresses and, e.g., ethernet addresses (MAC addresses). The software that
    performs this translation is called Address Resolution Protocol (ARP).

    The 'arp' command returns the ARP table, which is a list of IP addresses directly accessible to the
    machine (physically connected, no intervening gateway/router) and their associated hardware addresses.

    NetworkManager:
    ---------------
      NetworkManager is a newer addition to the Unix/Linux world which provides a lot of high-level
      control over networking and attempts to simplify network management.  There's a whole lot to it,
      but here are some basic things I've found handy.

      Connection Files:
      -----------------
        Connection files are stored in /etc/NetworkManager/system-connections
        A file is generated for every network you join (if it is a mobile device you've taken many
        places, you'll see a lot of familiar WIFI network names here).  You can also create connections
        manually via the gui (i.e. GNOME) or tools like 'nmcli'.  Alternatively, you can create/edit a
        connection file manually and apply the changes by reloading the connections with:

          nmcli con reload

        Example Connection File:
        ------------------------
          [connection]
          id=local
          uuid=939cba4e-b007-3377-8e8e-781296fe6feb
          type=ethernet
          autoconnect-priority=-999
          interface-name=enxd8ec5e7460f4
          permissions=

          [ethernet]
          mac-address-blacklist=

          [ipv4]
          address1=192.168.19.10/19
          ignore-auto-dns=true
          ignore-auto-routes=true
          dns-search=
          method=manual
          route1=192.168.19.0/24

          [ipv6]
          addr-gen-mode=stable-privacy
          dns-search=
          method=auto

diff and patch:
    The 'diff' function output is actually the exact same syntax as a patchfile.  If the output
    is redirected to a file, you can use it as a patchfile.
    In all the commands below, we use the '-u' (unified) flag to tell diff to also output some
    context lines (unchanged lines) to help patch locate the exact location of the change.
    If we used '-u' for the diff command, we must use '-u' for the patch command.
    diff -u fileOld fileNew                 # Show the difference between fileOld and fileNew
    diff -u fileOld fileNew > changes.patch # Capture the output into patchfile 'changes.patch'
    patch -u fileOld -i changes.patch       # Apply the changes in 'changes.patch' to fileOld
    patch -u -b fileOld -i changes.patch    # Do the above and also create a backup of fileOld

Handy Examples:
    # Search /.../words for pattern 'ie' (returns a lot!) - pipe to 'less' to paginate
    grep ie /usr/share/dict/words | less
    # Find recent messages regarding terminal devices (i.e. USB-to-Serial adapters)
    dmesg | grep tty
    # Echo PATH with single path per line
    echo $PATH | tr ':' '\n'
